# this file was generated with dbt init with dbt 1.2.1

models:
  - name: my_first_dbt_model
    description: "A starter dbt model"
    columns:
      - name: id
        description: "The primary key for this table"
        tests:
          - unique
          - not_null

  - name: my_second_dbt_model
    description: "A starter dbt model"
    columns:
      - name: id
        description: "The primary key for this table"
        tests:
          - unique
          - not_null

  - name: my_contracted_dbt_model
    description: "A dbt model with contracts"
    access: public
    group: analytics
    latest_version: 2
    config:
      contract: 
        enforced: true
    columns:
      - name: id
        description: "The primary key for this table"
        data_type: int
        constraints: 
          - type: not_null
          - type: unique
          - type: check
            expression: (id > 0)
        tests:
          - unique
          - not_null
    versions:
      - v: 2
        columns:
          - include: '*'
            exclude: country_name
          - name: id  # included in addition the '*' set. if id were in the '*' set -> override it
            description: This is the primary key
            data_type: float
      - v: 1
        config:
          alias: dim_customers
  
  - name: my_model_level_contract_model
    config:
      contract:
        enforced: true
    constraints:
    - type: check
      expression: (id > 0)
    - type: primary_key
      columns: [ id ]
    - type: unique
      columns: [ color, date_day ]
      name: strange_uniqueness_requirement


snapshots:
  - name: snapshot_name
    description: slowly changing dimension
    columns:
      - name: id 
        description: cool column, eh?


# model groups 

groups:
  - name: analytics
    owner:
      name: dave

semantic_models:
  #The name of the semantic model.
  - name: orders
    description: |
      Model containting order data. The grain of the table is the order id.
    
    #The name of the dbt model and schema
    model: ref('orders')
    defaults:
      agg_time_dimension: ds
    #Entities. These usually corespond to keys in the table.
    entities:
      - name: order_id
        type: primary
      - name: location
        type: foreign
        expr: location_id
      - name: customer
        type: foreign
        expr: customer_id

    #Measures. These are the aggregations on the columns in the table.
    measures:
      - name: order_total
        agg: sum
      - name: food_orders
        expr: case when is_food_order then order_total else 0 end
        agg: sum
      - name: orders
        expr: "1"
        agg: sum
      - name: max_order_total
        expr: order_total
        agg: max
      - name: min_order_total
        expr: order_total
        agg: min
      - name: customers
        expr: customer_id
        agg: count_distinct
      - name: average_order_total
        expr: order_total
        agg: average
      - name: order_cost
        agg: sum
        description: test
      - name: locations_with_orders
        expr: location_id
        agg: count_distinct
      - name: median_order_total
        expr: order_total
        agg: median
      - name: order_total_p99
        expr: order_total
        agg: percentile
        agg_params:
          percentile: 0.99
          use_discrete_percentile: True
          use_approximate_percentile: False
        agg_time_dimension: ds
      - name: discrete_order_total_p99
        expr: order_total
        agg: percentile
        agg_params:
          percentile: 0.99
          use_discrete_percentile: True
          use_approximate_percentile: False

  #Dimensions,either categorical or time. These add additonal context to metrics. The typical querying pattern is Metric by Dimension.
    dimensions:
      - name: location_name
        type: categorical
        description: hello
      - name: ds
        expr: cast(ordered_at as date)
        type: time
        type_params:
          time_granularity: day
      - name: is_food_order
        type: categorical
      - name: is_drink_order
        type: categorical
      - name: order_total_dim
        type: categorical
        expr: order_total
      - name: is_large_order
        type: categorical
        expr: case when order_total > 50 then true else false end


metrics:
  - name: new_customers
    label: New Customers marked 'paying'
    model: ref('dim_model_7')
    description: "The number of paid customers using the product"

    calculation_method: count
    expression: user_id # superfluous here, but shown as an example

    timestamp: signup_date
    time_grains: [day, week, month]

    dimensions:
      - plan
      - country

    filters:
      - field: is_paying
        operator: '='
        value: 'true'
      - field: company_name
        operator: '!='
        value: "Acme', Inc"

    meta: 
      team: "Finance"
      refresh_rate: "Bob's weekly run"

  - name: derived_metric
    label: New Customers marked 'paying'
    description: "The number of paid customers using the product"

    calculation_method: derived
    expression: "{{ metric('new_customers') }} * 2" 

    window:
      count: 14
      period: day
